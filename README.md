# FastChat-221BHackerStreet

## How To Run:

Make sure that there is a folder named mykeys and a folder named images at the location where the python sripts are.

Run fastchatdb_schema.py, then run keyserver.py, then fake_lb.py. Follow this by running mutiple_servers.py 5 times with 5 different command line arguments, 5001, 5002, 5003, 5004, 5005. Once this is done, all servers and background systems are up. Follow this by running fake_client.py. Over there, enter your username. We allow only unique usernames in our system and hence if the username has been seen before the system detects you as an existing user and askes you to enter your password. Otherwise the system identifies you as a new user and requests you to create a password.
There is no provision for password updation at the moment.

Once in the system, you are given a menu. type out the digit corresponding to what ypu want to do. Respond to prompts based on your understanding. When entering a comma separated list of usernames, eg for group creation/management, make sure to put quotes around each username.

If you're offline, the system will wait till you come back online to deliver messages to you. These messages will be recieved but not displayed when you login. The system will tell you the number of messages + images that arived while you were away. Messages that you choose to view will be displayed directly on the terminal. Images on the other hand will be downloaded into the images folder where your python scripts are running.

The terminal will tell you who sent the message.

## Features, Techniques etc:

### Concept of Selectors

Throughout the project, we have used selectors to manage the sockets. When we perform selectors.select, we can input a list of sockets and retrieve a list of sockets that have buffered, incoming data. This can be done in while true in a loop to continuously check for sockets which are receiving data.

### Servers are safe from clients crashing

A try-except block protects servers from throwing any errors if a client crashes.

### Initial Connection

The system ensures smooth flow of messages between clients. When a new client registers, they need to contact the load balancer and get the server number to which they have to connect. The client is connected to this server for the whole session.

### Malicious Clients During Load Balancing

We intend to make sure that the client is not able to connect with any other server, without having taken permission from the load balancer. For this, an authentication token is generated by the load balancer and is sent to the connecting client as well as to the corresponding server. The client when connecting to the server, must send their username and this token in the first message to the server. The server ensures that the client has indeed been sent by the load balancer.

### Password Authentication

Once the server ensures that a legitimate client has connected it checks if that username has registered yet. If yes, it sends back a request for password authentication. Otherwise it sends back a request for password creation. The client appropriately handles the response and procures the password from the user. If password authentication is taking place, it only allows 3 incorrect attempts before it disconnects the client from the server.
When registering as a new user, the client encrypts its password using the public key of the servers and forwards it to one of the servers. The respective server then decrypts the ciphertext to get the password. It then generates a salt and stores the hash of the password along with the salt in the database. The salt is also stored in the database. The hash being used is the bcrypt hash function. The bcrypt, being a slow hash function, makes it extemely time-consuming for an attacker to compute a rainbow table of all the hashes for a given salt.
When an existing user wishes to log in, a server generates a new AES_CBC key and IV, and sends them over to the client using encryption with the client's public key. The client decrypts the ciphertext to retrieve the key and IV which it then uses to encrypt its password. It then sends the encrypted password to the server. The server, on reception of the encrypted password, decrypts the ciphertext and hash the received password using the respective salt and checks where the computes hash matches with the stored hash to verify the authenticity of the user.

### Keyserver registration for new clients

If a new user has registered, they need to register themselves with the keyserver for the purpose of RSA end-to-end encryption. A new client is prompted by the server to register with the keyserver. The client at this point generates a public and private RSA key pair and contacts the keyserver. It sends over its public key to the keyserver which will be used by any other client messaging this client for encryption. User keys cannot be overwritten.

### Users table databasing

The servers mantain a shared database where they mantain user data. This includes username which is the unique identifier, password hash, salt and the current server number to which that user is connected. The current server number gets updated at the start of each session of the user.

At this point connection is complete and the user is prompted with a menu to decide what they want to do.

The menu:  
Enter Command No.:
RECEIVE MESSAGES 2) RECEIVE IMAGES 3) SEND MESSAGE 4) SEND IMAGE 5) SEND GROUP MESSAGE 6) SEND GROUP IMAGE 7) CREATE GROUP 8) MANAGE MY GROUPS 9) QUIT

Let us first discuss the situation without groups:

### Message encryption and sending

When a user(sender) selects send message, they are prompted to enter username of receiver(this is unique) followed by message contents. We have implemented RSA end-to-end encryption, so the message is encrypted using the public key of the receiver. If the user does not have the required public key in local storage, it prompts the keyserver which sends it the public key. The keyserver digitally signs the public key being sent and the client verifies the digital signature before proceeding. The public key is then stored in local storage and the sender need not ping the keyserver everytime it wishes to chat with the same receiver. This is the most space and time efficient solution we could devise for end-to-end encryption. The message is then sent to the server with all the data regarding the type, purpose, sender, receiver, encrypted content etc.

In the case of images, a similar thing takes place. The client prompts the user to enter the path of the image and then retrieves the image from that location. In this case however ,we have to encrypt not only the image content, but also the image name. Both get encrypted and sent over the server. The path remains private and is not sent over, the image name field only contains the title and the extension of the image file.

### Message handling at server

The server recieves the message from the client. It observes that this is a one to one message and detects the name of the receiver. It then opens the database and checks which server number that user was connected to when that user last came online. If this server is that server, it views all clients connected to it and sends the message to the suitable user. If the client was last connected to some other server. it sends the whole message to that server to handle. When a message comes to a server through the server-server channel it assumes that the client for whom the message is meant is connected to that server. If the client is not found connected to the server which is given in the database, we assume that this is an offline client.

For offline clients, the message is stored in the message handling table. Currently it is stored for infinite time. For online clients, the message is sent to the appropriate client by its connected server.

### Message Reception and Decryption at Client

When a client recieves a message from a server, it just stores it in the python script until the user chooses to read. Remember: if the user is online but just chooses to not read received messages then the system will delete the messages when the user exits the python script. Message storage at the server only takes place in case of offline users. Message decryption will also not take place until the user tries to read the message.

When the user chooses to read messages received, the system decrypts the message using the locally stored private key and displays it. This is along with the sender's name.

The client may choose to receive images in which case any received images will be downloaded and the sender's name will be printed onto the terminal.

### Unsent message reception

When an existing client logs in and connects to the server, the server sends all of the stored messages that were meant for this client and stored because the client was offline. These messages are recieved by the client and it print out "You have n unread messages". The user may then choose to read these messages/images as usual.

Lets take a look at what is extra in the case of groups:

### Groups Creation

#### Input Format

When a new group is to created, the user enters the group name and the members they wish to add to the group. These members must be entered as strings within quotes, comma separated. In case of one user, only enter "username", (the comma at the end is important)

#### Server, Database Stuff

The message for group creation is then sent to the server who creates that group in the database. The creator of the group is marked as the admin.
Note, if the group name exists the client will not be allowed to create this group.

#### Key creation and Keyserver

The admin at this point creates a group RSA key. The public key for this is sent to the keyserver to deal with as a regular key. We allow for same name of groups and users hence the keyserver table also stores a type to differentiate between the 2.

#### Group Private Key Distribution

The private key needs to get to all the group members but must not be accessible by anyone else. These primary keys are encrypted using the public key of each of the users and is sent over with 'class'='group invite'. These messages are received as regular messages by all the members, but when they read them, the group private key is downloaded into their local storage and they are alerted that they have joined a new group.

### Groups Management

#### Input Format

The user enters the group name and what they wish to do, i.e add/remove members. Then, these members must be entered as strings within quotes, comma separated. In case of one user, only enter "username", (the comma at the end is important)

#### Server, Database Stuff

The message for group updation is sent to the server. If the user who is requesting an updation is not the admin for the relevant group, then the request is declined and a suitable error message is sent back. If they are an admin, the group members list is updated in the GROUPS table for that group as intended by the user.

From here, adding and removing members follow different processes.

#### Adding members, Key Handling

The admin retrieves the public and private keys for the group from local storage. This key is sent to the new users as group invites. The key is encrypted using the receivers public key. The new members receive the group private key as well as the notification of having been added to a group.

#### Removing members, Key Handling

When we remove some members from the group, it is imprtant that they no longer have access to group messages. i.e they shouldn't be able to decrypt messages anymore. For this purpose, a new public-private key pair is generated by the admin. This new group key is sent to the keyserver to update it there and the new private keys are sent to all the remaining members of the group, encrypted using their individual public keys. The members receive this message as a group invite. When they read this message, the private key is overwritten in their local storage and so is the public key(To be implemented)

### Group messages

When a client sends a group message, the message arrives at the server with the group name, 'class'='group message' and message content, encrypted with the group private key. If the client is not part of the group, the server sends back an error saying that the client is not part of the group. The server handles this by breaking that group message into messages to individual receivers(all group members) and forwards it ahead as a regular 1 to 1 message. All group members, hence receive the message. Group message storage happens in the same table as one to one messages. The decryption for group messages happens using the group private key.

## Message forwarding between python scripts: protocol

Has gone through many updates, not accurate at the moment. Refer to code.

scripts will share messages as json files of dictionaries. Do a json load. The dictionary has a field: 'command' which will be present in all such dictionaries. It contains what to do with the dictionary.

For load_balancer connection by client: {'command':'ping'}
For message sent by load balancer to user: {'command':'authentication token', 'server port':'server socket number', 'token':'token'}
For message sent by load balancer to suitable server: {'command':'authentication token', 'token':'token'}

Client makes initial connection with server, {'command':'first connection', 'authentication token':'token', 'username':'name'}

Server checks token and then checks if username present in database.
If wrong token, reject connection from client. Send back a message {'command':'error','type':'wrong authentication token'}

If username is new, Send back a message: {'command':'new user'}. User should be shown suitable message by client and client will send back created password. The message will be of the form: {'command':'new password', 'password':'password'}. Server stores this username, password in database. Sends back message: {'command':'register for keyServer'} (note: keyserver uses a database to store keys of all registered users).
User at this point connects to key server at port 5013. Sends message {'command':'STORE', 'username':'username', 'key':'key'}. Keyserver sends back either {'command':'ERROR'} which implies user already exists or it sends back {'command':'INFO'} which means successful keyserver insertion done.
Then user disconnects from keyserver and starts sending regular messages.

If username exists, send back a message: {'command':'existing user'}. User should be shown suitable message by client and client will send back user entered password. Message of form: {'command':'password authenticate', 'password': 'password'}. Server checks password. If wrong, send back message: {'command':'re-enter'}. This causes process to repeat.
If password wrong more than 3 times, server sends message {'command':'error', 'type':'wrong password error'}. Server then disconnects from client.
Once client properly connected and authenticated, read pending messages from the database. If any messages found, send a message to client: {'command':'pending messages', 'messages':[] (this is an array of all messages, each has regular message format)}.

Once a client is online and messaging, they type their messages. A client is expected to enter either 'SEND' or 'READ'. If the client enters READ, they are prompted to enter a username. They may also enter 'all'. If they enter the username, all messages recieved from that username are showed. Otherwise, all messages recieved are displayed along with sender usernames.

If client enters SEND, they are prompted to enter their message as well as the username of the reviever. client makes socket connection with keyserver. Sends message to key server of form {'command':'RETRIEVE', 'username':'userxyz'} to get public key of userxyz. Key server sends back message {'command':'PUBKEY', 'pubkey':'key'}. Keyserver could also return {'command':'error'...} which means user not found etc.

Client uses that key to encrypt the message and then sends message to their server. {'command':'user-user message', 'encrypted message':'message', 'reciever username':'userxyz', 'sender username':'user1'}.

When a server recieves a message from client, it checks command. If command=='user-user message'. Server then checks if given username is connected to that server in its socket list. If yes, directly send back a message to suitable user : {'command':'user-user message', 'encrypted message':'message', 'reciever username':'userxyz', 'sender username':'user1'}.

If given username not connected to that server, open database and find that user. Server then sees which server that user is connected to and send a message to that server over the server-server socket. message:{'command':'user-user message', 'encrypted message':'message', 'reciever username':'userxyz', 'sender username':'user1'}. This message is recieved by other server on server-server socket. It forwards message as:
{'command':'user-user message', 'encrypted message':'message', 'reciever username':'userxyz', 'sender username':'user1'} to suitable user connected to it. If user not found at this stage, i.e user not found connected to the server it was supposed to be connected to, then store the message in the database, with other details.

When a client recieves a message, if it has command=='user-user message', store the message data in the list mantained by the python script. allow user to read from this list.

Group protocol:

Client has options in menu to create group and to manage groups for which they are an admin.
Group messages and images work just like ones to regular users. We need to choose different option from menu tho

Keyserver should store type of client. 'type' = 'fastchatter' or 'type' = 'group'. Group members is stored in the table as a list converted to string.

If client creates group, prompted to enter group name, number of members followed by usernames of all the members.
The admin at this point will create a new group private key which is stored locally and a group public key. The admin will
connect to the keyserver and get the public key regisered there.

After this, the admin will send a special kind of command to the server:
{'command':'create group', 'group name': 'name', 'admin':'admin username', 'member list':[list of member usernames]}
The server will recognise this request and add the suitable entry to the groups table.

At this point, the client encrypts the group private key with the public key of each of the members it wishes to add. and creates separate
messages of the form:
{'command':'user-user message', 'encrypted message':'message', 'reciever username':'userxyz', 'sender username':'user1', 'type' = 'message', 'class':'group invite', 'group name':'groupname'}
This message is handled like all others, nothing new. Only when a client recieves it and sees the class = 'group invite', they treat it as the
invite for a group.They save the private key for the group in local storage and add the group name to a locally mantained list of
'available groups'.

Note, for just a message/img from user to user 'class' = 'user message'

A group admin mantains a list of my_groups locally which contain group names of groups they are admin for. They may choose option manage
groups and then enter a group name from the list my groups. If the group exists in the list, admin is promted to either add or delete members.

If members to be added, same group private key is sent over to the new members as a group invite and server is also sent
{'command':'add to group', 'group name': 'name', 'member list':[list of users to be added]}
Group table is suitably updated.

To send group message, encrypt it with group public key and send. message will go as:
{'command':'user-user message', 'encrypted message':'message', 'receiver username':'', 'sender username':'user1', 'type' = 'message', 'class':'group message', 'group name' = 'group name'}

Server will detect that the message is a group message and accordingly forward it ahead to all mombers of the group which will be procured
from the database. Each client will recognise the class of the message as a group message and deal with it accordingly. The message displayed
should have the group name as well as the sender name on the reciever side

Note, on group creation, if group already exists then server will return suitable error. If on adding members, any members are already there in group then ignore them.

TODO: public keys may be in local storage or with keyserver.
